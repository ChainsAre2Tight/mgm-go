package bitstrings_test

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/ChainsAre2Tight/mgm-go/internal/bitstrings"
)

func TestSliceFromText(t *testing.T) {
	tt := []struct {
		in     []byte
		out    []*bitstrings.BitString128
		length uint64
	}{
		{
			in: []byte{
				0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
				0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
				0xEA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
			},
			out: []*bitstrings.BitString128{
				bitstrings.FromGOSTString("02 02 02 02 02 02 02 02 01 01 01 01 01 01 01 01"),
				bitstrings.FromGOSTString("04 04 04 04 04 04 04 04 03 03 03 03 03 03 03 03"),
				bitstrings.FromGOSTString("EA 05 05 05 05 05 05 05 05 00 00 00 00 00 00 00"),
			},
			length: 0x148,
		}, {
			in: []byte{
				0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
				0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xEE, 0xFF, 0x0A,
				0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xEE, 0xFF, 0x0A, 0x00,
				0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xEE, 0xFF, 0x0A, 0x00, 0x11,
				0xAA, 0xBB, 0xCC,
			},
			out: []*bitstrings.BitString128{
				bitstrings.FromGOSTString("11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88"),
				bitstrings.FromGOSTString("00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A"),
				bitstrings.FromGOSTString("11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00"),
				bitstrings.FromGOSTString("22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11"),
				bitstrings.FromGOSTString("AA BB CC 00 00 00 00 00 00 00 00 00 00 00 00 00"),
			},
			length: 0x218,
		},
	}
	for _, td := range tt {
		t.Run(
			fmt.Sprintf("%s -> %s", td.in, bitstrings.RepresentPointerArray(td.out)),
			func(t *testing.T) {
				if res, length := bitstrings.SliceFromText(td.in); !reflect.DeepEqual(res, td.out) || length != td.length {
					t.Fatalf("\nGot:  %s, \nWant: %s, \nLength: %d | %d",
						bitstrings.RepresentPointerArray(res),
						bitstrings.RepresentPointerArray(td.out),
						length, td.length,
					)
				}
			},
		)
	}
}

func TestTextFromSlice(t *testing.T) {
	tt := []struct {
		in     []*bitstrings.BitString128
		out    []byte
		length uint64
	}{
		{
			out: []byte{
				0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
				0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
				0xEA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
			},
			in: []*bitstrings.BitString128{
				bitstrings.FromGOSTString("02 02 02 02 02 02 02 02 01 01 01 01 01 01 01 01"),
				bitstrings.FromGOSTString("04 04 04 04 04 04 04 04 03 03 03 03 03 03 03 03"),
				bitstrings.FromGOSTString("EA 05 05 05 05 05 05 05 05 00 00 00 00 00 00 00"),
			},
			length: 0x148,
		}, {
			out: []byte{
				0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
				0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xEE, 0xFF, 0x0A,
				0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xEE, 0xFF, 0x0A, 0x00,
				0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xEE, 0xFF, 0x0A, 0x00, 0x11,
				0xAA, 0xBB, 0xCC,
			},
			in: []*bitstrings.BitString128{
				bitstrings.FromGOSTString("11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88"),
				bitstrings.FromGOSTString("00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A"),
				bitstrings.FromGOSTString("11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00"),
				bitstrings.FromGOSTString("22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11"),
				bitstrings.FromGOSTString("AA BB CC 00 00 00 00 00 00 00 00 00 00 00 00 00"),
			},
			length: 0x218,
		},
	}
	for _, td := range tt {
		t.Run(
			fmt.Sprintf("%s -> %s", bitstrings.RepresentPointerArray(td.in), td.in),
			func(t *testing.T) {
				if res, err := bitstrings.TextFromSlice(td.in, td.length); err != nil {
					t.Fatalf("error during conversion: %s", err)
				} else if !reflect.DeepEqual(res, td.out) {
					t.Fatalf("\nGot:  %s, \nWant: %s",
						res,
						td.out,
					)
				}
			},
		)
	}
}
